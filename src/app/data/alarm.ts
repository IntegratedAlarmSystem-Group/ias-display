import { Locale } from '../settings';
import * as moment from 'moment';


/**
* List of the possible Operational Modes
*/
export enum OperationalMode {
  startup = 0,
  initialization = 1,
  closing = 2,
  shuttedown = 3,
  maintenance = 4,
  operational = 5,
  degraded = 6,
  unknown = 7,
  malfunctioning = 8,
}

/**
* List of the possible Validity values
*/
export enum Validity {
  unreliable = 0,
  reliable = 1
}

/**
* List of the possible Values of an Alarm
*/
export enum Value {
  cleared = 0,
  set_low = 1,
  set_medium = 2,
  set_high = 3,
  set_critical = 4,
}

/**
* Class to define Alarm objects
*/
export class Alarm {

  /**
  * Value that represents the state of the {@link Alarm}.
  * Can be either 0 (CLEARED) or 1 (SET)
  */
  value: Value;

  /** Id used to identify the {@link Alarm} in the IAS Core */
  core_id: string;

  /** Id used to identify the {@link Alarm} and its parents in the IAS Core */
  running_id: string;

  /** Operational mode of the {@link Alarm} */
  mode: OperationalMode;

  /** Validity of the {@link Alarm} */
  validity: Validity;

  /** Timestamp at which the {@link Alarm} was generated by the IAS Core */
  core_timestamp: number;

  /** Timestamp at which the {@link Alarm} changed the state or the mode */
  state_change_timestamp: number;

  /** List of core_id's of dependent alarms **/
  dependencies: string[];

  /** Short description of the {@link Alarm} */
  description: string;

  /** Dictionary of alarms properties **/
  properties: {};

  /** Documentation url of the {@link Alarm} */
  url: string;

  /** Sound name to play when an {@link Alarm} changes to set */
  sound: string;

  /** Defines wether or not the {@link Alarm} can be shelved */
  can_shelve: boolean;

  /** Acknowledgement status */
  ack: boolean;

  /** Acknowledgement status */
  shelved: boolean;

  /**
  * Builds a new Alarm instance
  * @param {Object} attributes a dictionary containing the attributes to
  * create the object
  */
  constructor(attributes: Object = {}) {
    Object.assign(this, attributes);
  }

  /**
  * Class method that checks if an object corresponds to an Alarm object
  * @param {any} json the object to check
  * @returns {boolean} true if it is an {@link Alarm}, false if not
  */
  static isValidAlarm(json: any): boolean {
    return (
      json.hasOwnProperty('value') &&
      json.hasOwnProperty('core_id') &&
      json.hasOwnProperty('running_id') &&
      json.hasOwnProperty('mode') &&
      json.hasOwnProperty('core_timestamp') &&
      json.hasOwnProperty('state_change_timestamp') &&
      json.hasOwnProperty('validity') &&
      json.hasOwnProperty('description') &&
      json.hasOwnProperty('url') &&
      json.hasOwnProperty('sound') &&
      json.hasOwnProperty('can_shelve') &&
      json.hasOwnProperty('ack') &&
      json.hasOwnProperty('shelved') &&
      json.hasOwnProperty('dependencies')
    );
  }

  /**
  * Class method that receives an object and returns copy as an {@link Alarm}
  * @param {any} json the object to convert to an Alarm
  * @param {number} pk the primary key of the Alarm in the database
  * @returns {Alarm} the object as an {@link Alarm} instance
  */
  static asAlarm(json: any): Alarm {
    if (!this.isValidAlarm(json)) {
      return null;
    }
    const value = <number>json['value'];
    const core_id = <string>json['core_id'];
    const running_id = <string>json['running_id'];
    const mode = <number>json['mode'];
    const core_timestamp = <number>json['core_timestamp'];
    const state_change_timestamp = <number>json['state_change_timestamp'];
    const validity = <number>json['validity'];
    const description = <string>json['description'];
    const url = <string>json['url'];
    const sound = <string>json['sound'];
    const can_shelve = <boolean>json['can_shelve'];
    const ack = <boolean>json['ack'];
    const shelved = <boolean>json['shelved'];
    const dependencies = <string[]>json['dependencies'];
    const properties = json['properties'];
    return new Alarm({ value, core_id, running_id, mode, core_timestamp,
      state_change_timestamp, validity, description, url, sound, can_shelve, ack, shelved, dependencies, properties });
  }

  /**
  * Returns a string representation of the validity of the Alarm
  * @returns {string} a string representation of the {@link Alarm.mode} attribute
  */
  get alarmValidity(): string {
    return Validity[this.validity];
  }

  /**
  * Returns a string representation of the value of the Alarm
  *
  * @returns {string} a string representation of the {@link Alarm.value} attribute
  */
  get alarmValue(): string {
    return Value[this.value];
  }

  /** Returns the core_id of the {@link Alarm}*/
  get name(): string {
    return this.core_id;
  }

  /** Returns the operational mode of the {@link Alarm} as a string*/
  get operationalMode(): string {
    return OperationalMode[this.mode];
  }

  /**
  * Returns a string representation of the {@link Alarm.properties} attribute
  * @returns {string} a string representation of the Alarm properties
  */
  get formattedProperties(): string {
    if (this.properties === null || Object.keys(this.properties).length === 0) {
      return 'No properties';
    } else {
      return JSON.stringify(this.properties);
    }
  }

  /**
  * Getter that returns the {@link Alarm} status tags, needed for the displaying of status
  * through instances of {@link StatusViewComponent}. Calls {@link _getAlarmStatusTagsString()}
  * @returns {string} tags of the {@link Alarm} joined by "-"
  */
  get status(): string {
    return this._getAlarmStatusTagsString();
  }

  /**
  * Returns a Date representation of the {@link Alarm.state_change_timestamp} attribute
  * @returns {Date} a date format representation of the Alarm state_change_timestamp
  */
  get timestamp(): Date {
    const ts = this.state_change_timestamp;
    const date: Date = new Date(ts);
    return date;
  }

  /**
  * Returns a string representation according to the selected UTC offset in the app settings
  * for the {@link Alarm.state_change_timestamp} attribute
  * @returns {string} a date format representation of the Alarm state_change_timestamp
  */
  get formattedTimestamp(): string {
    const ts = this.state_change_timestamp;
    return moment(ts).utcOffset(Locale.TIMEZONE).format(Locale.MOMENT_DATE_FORMAT);
  }


  /**
  * Returns wether or not an {@link Alarm} should be displayed as in "maintenance" or "grayed out mode"
  * Currently this is true for alarms with {@link OperationalMode} of either:
  * - {@link OperationalMode.maintenance}
  * - {@link OperationalMode.shuttedown}
  * - {@link OperationalMode.malfunctioning}
  * @returns {boolean} true if the alarm should be displayed as in maintenance or false if not
  */
  showAsMaintenance(): boolean {
    if (this.mode === OperationalMode.maintenance ||
        this.mode === OperationalMode.shuttedown ||
        this.mode === OperationalMode.malfunctioning) {
      return true;
    } else {
      return false;
    }
  }

  /**
  * Returns wether or not an {@link Alarm} sound should be repeated
  * Currently this is true for critical alarms ({@link Value.set_critical})
  * @returns {boolean} true if the alarm sound should be repeated or false if not
  */
  shouldRepeat(): boolean {
    return this.value === Value.set_critical;
  }

  /**
  * Acknowledges the {@link Alarm} and returns the acknowledge status
  * @param {message} string string message of the acknowledgement
  * @returns {boolean} a the acknowledgement status
  */
  acknowledge(): boolean {
    this.ack = true;
    return this.ack;
  }

  /**
  * Shelves the {@link Alarm} and returns the shelve status
  * @param {message} string string message of the shelving
  * @returns {boolean} a the shelving message
  */
  shelve(): boolean {
    this.shelved = true;
    return this.shelved;
  }

  /**
  * Unshelves the {@link Alarm} and returns the shelve status
  * @returns {boolean} a the shelving status
  */
  unshelve(): boolean {
    this.shelved = false;
    return this.shelved;
  }

  /**
  * Returns the {@link Alarm} status tags, needed for the displaying of status
  * through instances of {@link StatusViewComponent}
  * @returns {string} tags of the {@link Alarm} joined by "-"
  */
  private _getAlarmStatusTagsString(): string {
    const shelved = this.shelved;
    const value_tags = this.alarmValue.split('_');
    let value = value_tags[0];
    let priority = value_tags[1];
    let validity = this.alarmValidity;
    let ack = this.ack;

    if (shelved) {
      value = 'cleared';
      priority = '';
      validity = 'reliable';
      ack = true;
    }

    const order = this._getAlarmStatusOrder(value, priority, validity, ack, shelved);

    const tags = [];
    tags.push(order);
    tags.push(this.operationalMode);
    tags.push(this.name);
    return tags.join('-');
  }

  /**
  * Returns a string with a number that defines the place where the {@link Alarm} should be displayed on the Table according to the
  * sorting by "Status" column
  *
  * @param {string} value string representation of the value of the {@link Alarm}
  * @param {string} priority string representation of the priority of the {@link Alarm}
  * @param {string} validity string representation of the validity of the {@link Alarm}
  * @param {boolean} ack the ack status of the {@link Alarm}
  * @returns {string} order for the {@link Alarm} in the Table
  */
  private _getAlarmStatusOrder(
    value: string, priority: string, validity: string, ack: boolean, shelved: boolean): string {
    let order = 0;
    const priorities = ['critical', 'high', 'medium', 'low'];

    // SET:
    if (value === 'set') {
      if (validity === 'reliable') {
        if (ack === false) {
          order = priorities.indexOf(priority);
        } else {
          order = 4 + priorities.indexOf(priority);
        }
      } else {
        if (ack === false) {
          order = 8 + priorities.indexOf(priority);
        } else {
          order = 12 + priorities.indexOf(priority);
        }
      }
    } else {
    // CLEARED:
      if (validity === 'reliable') {
        if (ack === false) {
          order = 16;
        } else {
          order = 17;
        }
      } else {
        if (ack === false) {
          order = 18;
        } else {
          order = 19;
        }
      }
    }
    if (order < 10) {
      return ('0' + order);
    } else {
      return ('' + order);
    }
  }
}
